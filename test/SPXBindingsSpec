{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -Wno-orphans #-}
{-# LANGUAGE InstanceSigs      #-}

module SPXBindingsSpec where

import           Control.Exception (evaluate)
import           Control.Monad     (forM_)
import           Data.Bits         (xor)
import           Data.ByteString   (ByteString, unpack)
import qualified Data.ByteString   as BS
import           Data.Maybe        (fromMaybe)
import           SPXBindings       (cryptoSignBytes, cryptoSignPublicKeyBytes,
                                    cryptoSignSecretKeyBytes,
                                    cryptoSignSeedBytes, generateKeypair, sign,
                                    verify)
import           System.IO.Unsafe  (unsafePerformIO)
import           Test.Hspec        (Spec, anyErrorCall, describe, it, shouldBe,
                                    shouldThrow)
import           Test.QuickCheck   (Arbitrary (arbitrary), Gen,
                                    Testable (property), choose, vectorOf,
                                    (==>))

instance Arbitrary ByteString where
  arbitrary :: Gen ByteString
  arbitrary = do
    len <- choose (0, 256)
    bytes <- vectorOf len arbitrary
    return $ BS.pack bytes

spec :: Spec
spec =
  describe "SPHINCS+ Binding Tests" $ do
    it "Returns correct sizes for keys and signature" $ do
      pkSize <- cryptoSignPublicKeyBytes
      skSize <- cryptoSignSecretKeyBytes
      sigSize <- cryptoSignBytes
      seedSize <- cryptoSignSeedBytes
      pkSize `shouldBe` 32
      skSize `shouldBe` 64
      sigSize `shouldBe` 7856
      seedSize `shouldBe` 32
    it "Generates valid keypair" $
      property $ \seed ->
        BS.length seed ==
        unsafePerformIO cryptoSignSeedBytes ==>
        let (pub, sec) = unsafePerformIO $ generateKeypair seed
         in BS.length pub == unsafePerformIO cryptoSignPublicKeyBytes &&
            BS.length sec == unsafePerformIO cryptoSignSecretKeyBytes
    it "Signs and verifies a message correctly" $
      property $ \seed message ->
        BS.length seed == unsafePerformIO cryptoSignSeedBytes &&
        BS.length message >
        0 ==>
        let (pub, sec) = unsafePerformIO $ generateKeypair seed
            sig = unsafePerformIO $ sign message sec
         in unsafePerformIO (verify message sig pub)
    it "Fails to verify corrupted signatures" $ do
      seed <- randomSeed
      let (pub, sec) = unsafePerformIO $ generateKeypair seed
      let message = BS.pack [1, 2, 3, 4]
      let sig = unsafePerformIO $ sign message sec
      let corruptedSig = BS.pack $ map (`xor` 0xFF) (unpack sig)
      valid <- verify message corruptedSig pub
      valid `shouldBe` False
    it "Handles large messages" $ do
      seed <- randomSeed
      let (pub, sec) = unsafePerformIO $ generateKeypair seed
      let message = BS.replicate (2 ^ (20 :: Integer)) 0xAA
      let sig = unsafePerformIO $ sign message sec
      result <- verify message sig pub
      result `shouldBe` True
    it "Fails on invalid seed length" $ do
      let seed = BS.replicate 5 0xFF -- Incorrect length
      evaluate (generateKeypair seed) `shouldThrow` anyErrorCall
    it "Fails on invalid signature length" $ do
      seed <- randomSeed
      let (pub, _) = unsafePerformIO $ generateKeypair seed
      let message = BS.pack [1, 2, 3, 4]
      let sig = BS.pack [0x01, 0x02] -- Incorrect length
      valid <- verify message sig pub
      valid `shouldBe` False
    it "Verifies expected sizes for parameter sets" $ do
      forM_ paramSets $ \param -> do
        let sizes = fromMaybe [] $ lookup param expectedSizes
        pkSize <- cryptoSignPublicKeyBytes
        skSize <- cryptoSignSecretKeyBytes
        sigSize <- cryptoSignBytes
        pkSize `shouldBe` head sizes
        skSize `shouldBe` sizes !! 1
        sigSize `shouldBe` sizes !! 2

-- Helper Functions
paramSets :: [String]
paramSets =
  [ "shake_128s"
  , "shake_128f"
  , "shake_192s"
  , "shake_192f"
  , "shake_256s"
  , "shake_256f"
  , "sha2_128s"
  , "sha2_128f"
  ]

expectedSizes :: [(String, [Int])]
expectedSizes =
  [ ("shake_128s", [32, 64, 7856])
  , ("shake_128f", [32, 64, 17088])
  , ("shake_192s", [48, 96, 16224])
  , ("shake_192f", [48, 96, 35664])
  , ("shake_256s", [64, 128, 29792])
  , ("shake_256f", [64, 128, 49856])
  , ("sha2_128s", [32, 64, 7856])
  , ("sha2_128f", [32, 64, 17088])
  ]

randomSeed :: IO ByteString
randomSeed = do
  seedSize <- cryptoSignSeedBytes
  return $ BS.replicate seedSize 0xAA
